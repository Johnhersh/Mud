@rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false))
@page "/Game"
@attribute [Authorize]
@using Microsoft.AspNetCore.Authorization
@using Mud.Core
@using Mud.Core.World
@using Mud.Client.Services
@using Mud.Client.Rendering
@using Mud.Client.Input
@inject GameClient GameClient
@inject GameRenderer Renderer
@inject ImmediateCommands ImmediateCommands
@inject IJSRuntime JS
@implements IAsyncDisposable

<PageTitle>Mud</PageTitle>

<CharacterSheet IsOpen="_characterSheetOpen" OnClose="CloseCharacterSheet" OnAllocateStat="AllocateStat"
    PlayerName="@(_playerEntity?.Name ?? "")" Level="@(_progression?.Level ?? _playerEntity?.Level ?? 1)"
    Experience="@(_progression?.Experience ?? 0)"
    Strength="@(_progression?.Strength ?? ProgressionFormulas.BaseStrength)"
    Dexterity="@(_progression?.Dexterity ?? ProgressionFormulas.BaseDexterity)"
    Stamina="@(_progression?.Stamina ?? ProgressionFormulas.BaseStamina)"
    UnspentPoints="@(_progression?.UnspentPoints ?? 0)" />

<div id="game-container">
    <h1>Mud V0</h1>

    @if (_snapshot != null)
    {
        <p>
            Tick: @_snapshot.Tick |
            World: @_snapshot.WorldId (@_snapshot.WorldType) |
            Entities: @_snapshot.Entities.Count |
            Target: @(_targetId ?? "None")
        </p>
    }

    <div style="position: relative;">
        <div id="phaser-container" style="width: 800px; height: 600px; border: 1px solid #ccc; background: #000;"></div>

        @if (_status != GameStatus.Playing)
        {
            <div class="status-overlay">
                @switch (_status)
                {
                    case GameStatus.InitializingRenderer:
                        <p>Initializing renderer...</p>
                        break;
                    case GameStatus.Connecting:
                        <p>Connecting to server...</p>
                        break;
                }
            </div>
        }

        @if (!string.IsNullOrEmpty(_interactionPrompt))
        {
            <div class="interaction-prompt">
                @_interactionPrompt
            </div>
        }
    </div>
</div>

@code {
    private enum GameStatus { InitializingRenderer, Connecting, Playing }

    private GameStatus _status = GameStatus.InitializingRenderer;
    private WorldSnapshot? _snapshot;
    private List<Direction> _localInputQueue = new();
    private string? _myPlayerId;
    private string? _targetId;
    private string? _interactionPrompt;
    private bool _characterSheetOpen;
    private Entity? _playerEntity;
    private ProgressionUpdate? _progression;
    private KeyboardHandler? _keyHandler;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Step 1: Initialize Phaser (container is now rendered)
            await JS.InvokeVoidAsync("initPhaser", "phaser-container");

            // Step 2: Register keyboard handler
            _keyHandler = await KeyboardHandler.CreateAsync(JS, keys => keys
                .Add(Code.ArrowUp, () => QueueMove(Direction.Up))
                .Add(Code.ArrowDown, () => QueueMove(Direction.Down))
                .Add(Code.ArrowLeft, () => QueueMove(Direction.Left))
                .Add(Code.ArrowRight, () => QueueMove(Direction.Right))
                .Add(Code.KeyW, () => QueueMove(Direction.Up))
                .Add(Code.KeyS, () => QueueMove(Direction.Down))
                .Add(Code.KeyA, () => QueueMove(Direction.Left))
                .Add(Code.KeyD, () => QueueMove(Direction.Right))
                .Add(Code.Tab, OnTabPressed)
                .Add(Code.KeyF, OnAttackPressed)
                .Add(Code.KeyC, ToggleCharacterSheet)
                .Add(Code.Enter, OnEnterPressed)
                .Add(Code.Escape, OnEscapePressed));

            // Step 3: Connect to server
            _status = GameStatus.Connecting;
            StateHasChanged();

            GameClient.OnWorldUpdate += HandleWorldUpdate;
            GameClient.OnXpGain += HandleXpGain;
            GameClient.OnProgressionUpdate += HandleProgressionUpdate;
            await GameClient.StartAsync();
            _myPlayerId = GameClient.ConnectionId;

            // Step 4: Join game - snapshots will now arrive with Phaser ready
            await GameClient.JoinAsync("Player" + Random.Shared.Next(100));
        }
    }

    private async void HandleWorldUpdate(WorldSnapshot snapshot)
    {
        _snapshot = snapshot;
        _myPlayerId = GameClient.ConnectionId;
        _status = GameStatus.Playing;

        // Track player entity for character sheet
        _playerEntity = _snapshot.Entities.FirstOrDefault(e => e.Id == _myPlayerId);

        // Reconcile local queue with server state
        if (_playerEntity is not null)
        {
            while (_localInputQueue.Count > _playerEntity.QueuedPath.Count)
            {
                _localInputQueue.RemoveAt(0);
            }
        }

        // Validate target still exists
        if (_targetId is not null && !_snapshot.Entities.Any(e => e.Id == _targetId))
        {
            _targetId = null;
            await ImmediateCommands.SetTargetReticle(null);
        }

        // Phaser is guaranteed ready - just render
        await Renderer.ProcessSnapshot(snapshot, _myPlayerId!);

        // Get interaction prompt
        var interactionInfo = await JS.InvokeAsync<InteractionInfo?>("getInteractionInfo", snapshot, _myPlayerId);
        _interactionPrompt = interactionInfo?.Text;

        StateHasChanged();
    }

    private async void HandleXpGain(List<XpGainEvent> xpEvents)
    {
        await Renderer.ProcessXpEvents(xpEvents);
    }

    private void HandleProgressionUpdate(ProgressionUpdate progression)
    {
        _progression = progression;
        StateHasChanged();
    }

    // ============ KEYBOARD HANDLERS ============

    private async Task QueueMove(Direction dir)
    {
        if (_status != GameStatus.Playing || _characterSheetOpen) return;

        if (_localInputQueue.Count > 0)
        {
            var lastDir = _localInputQueue.Last();
            if (IsOpposite(lastDir, dir))
            {
                _localInputQueue.Clear();
                return;
            }
        }

        if (_localInputQueue.Count < 5)
        {
            _localInputQueue.Add(dir);
            await GameClient.MoveAsync(dir);
        }
    }

    private async Task OnTabPressed()
    {
        if (_status != GameStatus.Playing || _characterSheetOpen) return;
        await CycleTarget();
    }

    private async Task OnAttackPressed()
    {
        if (_status != GameStatus.Playing || _characterSheetOpen) return;
        if (_targetId != null)
        {
            _localInputQueue.Clear();
            await GameClient.RangedAttackAsync(_targetId);
        }
    }

    private async Task OnEnterPressed()
    {
        if (_status != GameStatus.Playing || _characterSheetOpen) return;
        await GameClient.InteractAsync();
    }

    private void OnEscapePressed()
    {
        if (_characterSheetOpen) CloseCharacterSheet();
    }

    private async Task CycleTarget()
    {
        if (_snapshot == null) return;

        var monsters = _snapshot.Entities.Where(e => e.Type == EntityType.Monster).ToList();
        if (!monsters.Any())
        {
            _targetId = null;
            await ImmediateCommands.SetTargetReticle(null);
            return;
        }

        if (_targetId == null)
        {
            _targetId = monsters.First().Id;
        }
        else
        {
            var currentIndex = monsters.FindIndex(m => m.Id == _targetId);
            if (currentIndex == -1 || currentIndex == monsters.Count - 1)
            {
                _targetId = monsters.First().Id;
            }
            else
            {
                _targetId = monsters[currentIndex + 1].Id;
            }
        }

        await ImmediateCommands.SetTargetReticle(_targetId);
    }

    private bool IsOpposite(Direction d1, Direction d2)
    {
        return (d1 == Direction.Up && d2 == Direction.Down) ||
        (d1 == Direction.Down && d2 == Direction.Up) ||
        (d1 == Direction.Left && d2 == Direction.Right) ||
        (d1 == Direction.Right && d2 == Direction.Left);
    }

    private void ToggleCharacterSheet()
    {
        if (_status != GameStatus.Playing) return;
        _characterSheetOpen = !_characterSheetOpen;
        StateHasChanged();
    }

    private void CloseCharacterSheet()
    {
        _characterSheetOpen = false;
        StateHasChanged();
    }

    private async Task AllocateStat(StatType stat)
    {
        await GameClient.AllocateStatAsync(stat);
    }

    public async ValueTask DisposeAsync()
    {
        GameClient.OnWorldUpdate -= HandleWorldUpdate;
        GameClient.OnXpGain -= HandleXpGain;
        GameClient.OnProgressionUpdate -= HandleProgressionUpdate;

        if (_keyHandler != null)
            await _keyHandler.DisposeAsync();
    }

    private class InteractionInfo
    {
        public string? Type { get; set; }
        public string? Text { get; set; }
    }
}