@rendermode InteractiveWebAssembly
@page "/"
@using Mud.Shared
@using Mud.Shared.World
@using Mud.Client.Services
@using Mud.Client.Rendering
@inject GameClient GameClient
@inject GameRenderer Renderer
@inject IJSRuntime JS
@implements IDisposable

<PageTitle>Mud</PageTitle>

<div @onkeydown="HandleKeyDown" @onkeydown:preventDefault="true" tabindex="0" style="outline: none;" id="game-container">
    <h1>Mud V0</h1>

    @if (_snapshot != null)
    {
        <p>
            Tick: @_snapshot.Tick |
            World: @_snapshot.WorldId (@_snapshot.WorldType) |
            Entities: @_snapshot.Entities.Count |
            Target: @(_targetId ?? "None")
        </p>
    }

    <div style="position: relative;">
        <div id="phaser-container" style="width: 800px; height: 600px; border: 1px solid #ccc; background: #000;"></div>

        @if (_status != GameStatus.Playing)
        {
            <div class="status-overlay">
                @switch (_status)
                {
                    case GameStatus.InitializingRenderer:
                        <p>Initializing renderer...</p>
                        break;
                    case GameStatus.Connecting:
                        <p>Connecting to server...</p>
                        break;
                }
            </div>
        }

        @if (!string.IsNullOrEmpty(_interactionPrompt))
        {
            <div class="interaction-prompt">
                @_interactionPrompt
            </div>
        }
    </div>
</div>

@code {
    private enum GameStatus { InitializingRenderer, Connecting, Playing }

    private GameStatus _status = GameStatus.InitializingRenderer;
    private WorldSnapshot? _snapshot;
    private List<Direction> _localInputQueue = new();
    private string? _myPlayerId;
    private string? _targetId;
    private string? _interactionPrompt;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Step 1: Initialize Phaser (container is now rendered)
            await JS.InvokeVoidAsync("initPhaser", "phaser-container");

            // Step 2: Connect to server
            _status = GameStatus.Connecting;
            StateHasChanged();

            GameClient.OnWorldUpdate += HandleWorldUpdate;
            await GameClient.StartAsync();
            _myPlayerId = GameClient.ConnectionId;

            // Step 3: Join game - snapshots will now arrive with Phaser ready
            await GameClient.JoinAsync("Player" + Random.Shared.Next(100));
        }
    }

    private async void HandleWorldUpdate(WorldSnapshot snapshot)
    {
        _snapshot = snapshot;
        _myPlayerId = GameClient.ConnectionId;
        _status = GameStatus.Playing;

        // Reconcile local queue with server state
        var me = _snapshot.Entities.FirstOrDefault(p => p.Id == _myPlayerId);
        if (me != null)
        {
            while (_localInputQueue.Count > me.QueuedPath.Count)
            {
                _localInputQueue.RemoveAt(0);
            }
        }

        // Validate target still exists
        if (_targetId != null && !_snapshot.Entities.Any(e => e.Id == _targetId))
        {
            _targetId = null;
        }

        // Phaser is guaranteed ready - just render
        Renderer.ProcessSnapshot(snapshot, _targetId, _myPlayerId!);
        await Renderer.FlushAsync();

        // Get interaction prompt
        var interactionInfo = await JS.InvokeAsync<InteractionInfo?>("getInteractionInfo", snapshot, _myPlayerId);
        _interactionPrompt = interactionInfo?.Text;

        StateHasChanged();
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (_status != GameStatus.Playing) return;

        if (e.Key == "Tab")
        {
            CycleTarget();
            return;
        }

        if (e.Key == "f")
        {
            if (_targetId != null)
            {
                _localInputQueue.Clear();
                await GameClient.RangedAttackAsync(_targetId);
            }
            return;
        }

        if (e.Key == "Enter")
        {
            await GameClient.InteractAsync();
            return;
        }

        Direction? dir = e.Key switch
        {
            "ArrowUp" or "w" => Direction.Up,
            "ArrowDown" or "s" => Direction.Down,
            "ArrowLeft" or "a" => Direction.Left,
            "ArrowRight" or "d" => Direction.Right,
            _ => null
        };

        if (dir.HasValue)
        {
            if (_localInputQueue.Count > 0)
            {
                var lastDir = _localInputQueue.Last();
                if (IsOpposite(lastDir, dir.Value))
                {
                    _localInputQueue.Clear();
                    return;
                }
            }

            if (_localInputQueue.Count < 5)
            {
                _localInputQueue.Add(dir.Value);
                await GameClient.MoveAsync(dir.Value);
            }
        }
    }

    private void CycleTarget()
    {
        if (_snapshot == null) return;

        var monsters = _snapshot.Entities.Where(e => e.Type == EntityType.Monster).ToList();
        if (!monsters.Any())
        {
            _targetId = null;
            return;
        }

        if (_targetId == null)
        {
            _targetId = monsters.First().Id;
        }
        else
        {
            var currentIndex = monsters.FindIndex(m => m.Id == _targetId);
            if (currentIndex == -1 || currentIndex == monsters.Count - 1)
            {
                _targetId = monsters.First().Id;
            }
            else
            {
                _targetId = monsters[currentIndex + 1].Id;
            }
        }
    }

    private bool IsOpposite(Direction d1, Direction d2)
    {
        return (d1 == Direction.Up && d2 == Direction.Down) ||
               (d1 == Direction.Down && d2 == Direction.Up) ||
               (d1 == Direction.Left && d2 == Direction.Right) ||
               (d1 == Direction.Right && d2 == Direction.Left);
    }

    public void Dispose()
    {
        GameClient.OnWorldUpdate -= HandleWorldUpdate;
    }

    private class InteractionInfo
    {
        public string? Type { get; set; }
        public string? Text { get; set; }
    }
}
