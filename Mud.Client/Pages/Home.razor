@rendermode InteractiveWebAssembly
@page "/"
@using Mud.Shared
@using Mud.Client.Services
@inject GameClient GameClient
@inject IJSRuntime JS
@implements IDisposable

<PageTitle>Mud</PageTitle>

<div @onkeydown="HandleKeyDown" tabindex="0" style="outline: none;" id="game-container">
    <h1>Mud V0</h1>

    @if (_snapshot == null)
    {
        <p>Connecting...</p>
    }
    else
    {
        <p>Tick: @_snapshot.Tick | Entities: @_snapshot.Entities.Count | Target: @(_targetId ?? "None")</p>
        <div id="pixi-container" style="width: 800px; height: 600px; border: 1px solid #ccc;"></div>
    }
</div>

@code {
    private WorldSnapshot? _snapshot;
    private bool _pixiInitialized = false;
    private List<Direction> _localInputQueue = new();
    private List<Point> _localQueuedPath = new();
    private string? _myPlayerId;
    private string? _targetId;

    protected override async Task OnInitializedAsync()
    {
        GameClient.OnWorldUpdate += HandleWorldUpdate;
        await GameClient.StartAsync();
        _myPlayerId = Guid.NewGuid().ToString(); // We should probably get this from the server, but for now...
        await GameClient.JoinAsync("Player" + Random.Shared.Next(100));
    }

    private async void HandleWorldUpdate(WorldSnapshot snapshot)
    {
        _snapshot = snapshot;
        
        // Reconcile local queue with server state
        var me = _snapshot.Entities.FirstOrDefault(p => p.Id == GameClient.ConnectionId);
        if (me != null)
        {
            // Update local input queue length based on server's queued path
            // This is a simple reconciliation: we assume server is truth
            while (_localInputQueue.Count > me.QueuedPath.Count)
            {
                _localInputQueue.RemoveAt(0);
            }
        }

        // Validate target still exists
        if (_targetId != null && !_snapshot.Entities.Any(e => e.Id == _targetId))
        {
            _targetId = null;
        }

        if (!_pixiInitialized && _snapshot != null)
        {
            _pixiInitialized = true;
            StateHasChanged();
            await Task.Delay(100); // Wait for container to render
            await JS.InvokeVoidAsync("initPixi", "pixi-container");
        }

        if (_pixiInitialized)
        {
            await JS.InvokeVoidAsync("renderSnapshot", snapshot, _targetId);
        }
        
        StateHasChanged();
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Tab")
        {
            CycleTarget();
            return;
        }

        if (e.Key == "f")
        {
            if (_targetId != null)
            {
                _localInputQueue.Clear();
                await GameClient.RangedAttackAsync(_targetId);
            }
            return;
        }

        Direction? dir = e.Key switch
        {
            "ArrowUp" or "w" => Direction.Up,
            "ArrowDown" or "s" => Direction.Down,
            "ArrowLeft" or "a" => Direction.Left,
            "ArrowRight" or "d" => Direction.Right,
            _ => null
        };

        if (dir.HasValue)
        {
            if (_localInputQueue.Count > 0)
            {
                var lastDir = _localInputQueue.Last();
                if (IsOpposite(lastDir, dir.Value))
                {
                    _localInputQueue.Clear();
                    // We'd need a way to tell server to clear too, 
                    // but for now let's just not add the opposite move.
                    return;
                }
            }

            if (_localInputQueue.Count < 5)
            {
                _localInputQueue.Add(dir.Value);
                await GameClient.MoveAsync(dir.Value);
            }
        }
    }

    private void CycleTarget()
    {
        if (_snapshot == null) return;

        var monsters = _snapshot.Entities.Where(e => e.Type == EntityType.Monster).ToList();
        if (!monsters.Any())
        {
            _targetId = null;
            return;
        }

        if (_targetId == null)
        {
            _targetId = monsters.First().Id;
        }
        else
        {
            var currentIndex = monsters.FindIndex(m => m.Id == _targetId);
            if (currentIndex == -1 || currentIndex == monsters.Count - 1)
            {
                _targetId = monsters.First().Id;
            }
            else
            {
                _targetId = monsters[currentIndex + 1].Id;
            }
        }
    }

    private bool IsOpposite(Direction d1, Direction d2)
    {
        return (d1 == Direction.Up && d2 == Direction.Down) ||
               (d1 == Direction.Down && d2 == Direction.Up) ||
               (d1 == Direction.Left && d2 == Direction.Right) ||
               (d1 == Direction.Right && d2 == Direction.Left);
    }

    public void Dispose()
    {
        GameClient.OnWorldUpdate -= HandleWorldUpdate;
    }
}
