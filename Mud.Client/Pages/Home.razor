@rendermode InteractiveWebAssembly
@page "/"
@using Mud.Shared
@using Mud.Shared.World
@using Mud.Client.Services
@using Mud.Client.Rendering
@inject GameClient GameClient
@inject GameRenderer Renderer
@inject ImmediateCommands ImmediateCommands
@inject IJSRuntime JS
@implements IDisposable

<PageTitle>Mud</PageTitle>

<CharacterSheet IsOpen="_characterSheetOpen" OnClose="CloseCharacterSheet" OnAllocateStat="AllocateStat"
    PlayerName="@(_playerEntity?.Name ?? "")" Level="@(_playerEntity?.Level ?? 1)"
    Experience="@(_playerEntity?.Experience ?? 0)" Strength="@(_playerEntity?.Strength ?? 5)"
    Dexterity="@(_playerEntity?.Dexterity ?? 5)" Stamina="@(_playerEntity?.Stamina ?? 5)"
    UnspentPoints="@(_playerEntity?.UnspentPoints ?? 0)" />

<div @onkeydown="HandleKeyDown" @onkeydown:preventDefault="true" tabindex="0" style="outline: none;"
    id="game-container">
    <h1>Mud V0</h1>

    @if (_snapshot != null)
    {
        <p>
            Tick: @_snapshot.Tick |
            World: @_snapshot.WorldId (@_snapshot.WorldType) |
            Entities: @_snapshot.Entities.Count |
            Target: @(_targetId ?? "None")
        </p>
    }

    <div style="position: relative;">
        <div id="phaser-container" style="width: 800px; height: 600px; border: 1px solid #ccc; background: #000;"></div>

        @if (_status != GameStatus.Playing)
        {
            <div class="status-overlay">
                @switch (_status)
                {
                    case GameStatus.InitializingRenderer:
                        <p>Initializing renderer...</p>
                        break;
                    case GameStatus.Connecting:
                        <p>Connecting to server...</p>
                        break;
                }
            </div>
        }

        @if (!string.IsNullOrEmpty(_interactionPrompt))
        {
            <div class="interaction-prompt">
                @_interactionPrompt
            </div>
        }
    </div>
</div>

@code {
    private enum GameStatus { InitializingRenderer, Connecting, Playing }

    private GameStatus _status = GameStatus.InitializingRenderer;
    private WorldSnapshot? _snapshot;
    private List<Direction> _localInputQueue = new();
    private string? _myPlayerId;
    private string? _targetId;
    private string? _interactionPrompt;
    private bool _characterSheetOpen;
    private Entity? _playerEntity;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Step 1: Initialize Phaser (container is now rendered)
            await JS.InvokeVoidAsync("initPhaser", "phaser-container");

            // Step 2: Connect to server
            _status = GameStatus.Connecting;
            StateHasChanged();

            GameClient.OnWorldUpdate += HandleWorldUpdate;
            GameClient.OnXpGain += HandleXpGain;
            await GameClient.StartAsync();
            _myPlayerId = GameClient.ConnectionId;

            // Step 3: Join game - snapshots will now arrive with Phaser ready
            await GameClient.JoinAsync("Player" + Random.Shared.Next(100));
        }
    }

    private async void HandleWorldUpdate(WorldSnapshot snapshot)
    {
        _snapshot = snapshot;
        _myPlayerId = GameClient.ConnectionId;
        _status = GameStatus.Playing;

        // Track player entity for character sheet
        _playerEntity = _snapshot.Entities.FirstOrDefault(e => e.Id == _myPlayerId);

        // Reconcile local queue with server state
        if (_playerEntity is not null)
        {
            while (_localInputQueue.Count > _playerEntity.QueuedPath.Count)
            {
                _localInputQueue.RemoveAt(0);
            }
        }

        // Validate target still exists
        if (_targetId is not null && !_snapshot.Entities.Any(e => e.Id == _targetId))
        {
            _targetId = null;
            await ImmediateCommands.SetTargetReticle(null);
        }

        // Phaser is guaranteed ready - just render
        await Renderer.ProcessSnapshot(snapshot, _myPlayerId!);

        // Get interaction prompt
        var interactionInfo = await JS.InvokeAsync<InteractionInfo?>("getInteractionInfo", snapshot, _myPlayerId);
        _interactionPrompt = interactionInfo?.Text;

        StateHasChanged();
    }

    private async void HandleXpGain(List<XpGainEvent> xpEvents)
    {
        await Renderer.ProcessXpEvents(xpEvents);
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (_status != GameStatus.Playing) return;

        // Character sheet toggle
        if (e.Key == "c" || e.Key == "C")
        {
            ToggleCharacterSheet();
            return;
        }

        // Escape closes character sheet
        if (e.Key == "Escape" && _characterSheetOpen)
        {
            CloseCharacterSheet();
            return;
        }

        // Block game input while character sheet is open
        if (_characterSheetOpen) return;

        if (e.Key == "Tab")
        {
            await CycleTarget();
            return;
        }

        if (e.Key == "f")
        {
            if (_targetId != null)
            {
                _localInputQueue.Clear();
                await GameClient.RangedAttackAsync(_targetId);
            }
            return;
        }

        if (e.Key == "Enter")
        {
            await GameClient.InteractAsync();
            return;
        }

        Direction? dir = e.Key switch
        {
            "ArrowUp" or "w" => Direction.Up,
            "ArrowDown" or "s" => Direction.Down,
            "ArrowLeft" or "a" => Direction.Left,
            "ArrowRight" or "d" => Direction.Right,
            _ => null
        };

        if (dir.HasValue)
        {
            if (_localInputQueue.Count > 0)
            {
                var lastDir = _localInputQueue.Last();
                if (IsOpposite(lastDir, dir.Value))
                {
                    _localInputQueue.Clear();
                    return;
                }
            }

            if (_localInputQueue.Count < 5)
            {
                _localInputQueue.Add(dir.Value);
                await GameClient.MoveAsync(dir.Value);
            }
        }
    }

    private async Task CycleTarget()
    {
        if (_snapshot == null) return;

        var monsters = _snapshot.Entities.Where(e => e.Type == EntityType.Monster).ToList();
        if (!monsters.Any())
        {
            _targetId = null;
            await ImmediateCommands.SetTargetReticle(null);
            return;
        }

        if (_targetId == null)
        {
            _targetId = monsters.First().Id;
        }
        else
        {
            var currentIndex = monsters.FindIndex(m => m.Id == _targetId);
            if (currentIndex == -1 || currentIndex == monsters.Count - 1)
            {
                _targetId = monsters.First().Id;
            }
            else
            {
                _targetId = monsters[currentIndex + 1].Id;
            }
        }

        await ImmediateCommands.SetTargetReticle(_targetId);
    }

    private bool IsOpposite(Direction d1, Direction d2)
    {
        return (d1 == Direction.Up && d2 == Direction.Down) ||
        (d1 == Direction.Down && d2 == Direction.Up) ||
        (d1 == Direction.Left && d2 == Direction.Right) ||
        (d1 == Direction.Right && d2 == Direction.Left);
    }

    private void ToggleCharacterSheet()
    {
        _characterSheetOpen = !_characterSheetOpen;
        StateHasChanged();
    }

    private void CloseCharacterSheet()
    {
        _characterSheetOpen = false;
        StateHasChanged();
    }

    private async Task AllocateStat(StatType stat)
    {
        await GameClient.AllocateStatAsync(stat);
    }

    public void Dispose()
    {
        GameClient.OnWorldUpdate -= HandleWorldUpdate;
        GameClient.OnXpGain -= HandleXpGain;
    }

    private class InteractionInfo
    {
        public string? Type { get; set; }
        public string? Text { get; set; }
    }
}